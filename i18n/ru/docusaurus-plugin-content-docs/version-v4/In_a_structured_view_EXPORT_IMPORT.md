---
title: 'В структурированном представлении (EXPORT, IMPORT)'
---

Этот оператор создает действие, которое [открывает форму](Open_form.md) в [структурированном](Structured_view.md) представлении.

### Формат {#format}

В этом операторе можно задать формат, в который будут преобразованы данные формы :  **XML**, **JSON**, **DBF**, **CSV**, **XLS**, после чего сформированный файл(ы) в этом формате записывается в заданное свойство.

Экспорт формы является общим случаем оператора [экспорта данных](Data_export_EXPORT.md).

### Импорт формы {#importForm}

Импорт формы - операция обратная открытию формы в структурированном представлении. Оператор импорта принимает на вход файл(ы) в структурированном формате, после чего разбирает его (их) и записывает полученные данные в свойства заданной формы, таким образом, чтобы при экспорте этой формы назад в импортируемый формат получить исходный файл.

Так как оператор импорта это по сути "оператор ввода", на импортируемую форму накладываются следующие ограничения:

-   Все объекты формы должны быть [числовых](Built-in_classes.md#inheritance) или [конкретных](User_classes.md#abstract) [пользовательских](User_classes.md) классов, причем группы объектов должны состоять ровно из одного объекта (это ограничение вытекает из того что все используемые форматы это по сути списки, то есть отображения чисел на значения).

-   Свойства на форме и [фильтры](Form_structure.md#filters) должны иметь возможность [изменения](Property_change_CHANGE.md) на заданное значение (то есть, как правило, быть [первичными](Data_properties_DATA.md)). Перед импортом все существующие изменения импортируемых свойств в текущей сессии отменяются.

Фильтры при импорте изменяются на [значения по умолчанию](Built-in_classes.md#defaultvalue) классов значений этих фильтров.

При импорте данных в объекты числовых классов используется 0-based нумерация, причем в [иерархичных](Structured_view.md#hierarchy) форматах она "сквозная" (то есть когда импортируемая группа объектов встречается второй и последующий разы, нумерация объектов в ней начинается с того числа, на котором закончилась предыдущая).

При импорте из XLS и CSV без заголовков (с опцией `NOHEADER`), платформа пытается автоматически преобразовать данные к требуемому типу. Если это не удается, в свойство записывается значение `NULL`. Импорты из остальных форматов требуют правильные типы. Например, если при импорте из JSON требуется строка, а в JSON будет число (то есть не будет кавычек), платформа выдаст ошибку.

Если при импорте свойство (группа объектов) не найдено, оно игнорируется (то есть его значение остается равным `NULL`).

Импорт формы является общим случаем оператора [импорта данных](Data_import_IMPORT.md).

### Язык

Синтаксис оператора открытия формы в структурированном представлении описывается [оператором `EXPORT`](EXPORT_operator.md). Для импорта формы используется [оператор `IMPORT`](IMPORT_operator.md).

### Примеры

```lsf
FORM exportSku
    OBJECTS st = Store

    OBJECTS s = Sku
    PROPERTIES(s) id, name, weight
    FILTERS in(st, s)
;

exportSku (Store store)  {
    // выгружаем в DBF все Sku, для которых задано in (Store, Sku) для нужного склада
    EXPORT exportSku OBJECTS st = store DBF CHARSET 'CP866';
    EXPORT exportSku XML;
    EXPORT exportSku OBJECTS st = store CSV ',';
}
```

```lsf

date = DATA DATE (INTEGER);
sku = DATA BPSTRING[50] (INTEGER);
price = DATA NUMERIC[14,2] (INTEGER);
order = DATA INTEGER (INTEGER);
FORM import
    OBJECTS o = INTEGER // заказы
    OBJECTS od = INTEGER // строки заказов
    PROPERTIES (o) dateOrder = date // импортируем дату из поля dateOrder
    PROPERTIES (od) sku = sku, price = price // импортируем товар количество из полей sku и price
    FILTERS order(od) = o // в order - записываем верхний заказ

;

importForm()  {
    INPUT f = FILE DO {
        IMPORT import JSON FROM f;
        SHOW import; // показываем что импортировалось

        // создаем объекты в базе
        FOR DATE date = date(INTEGER io) NEW o = Order DO {
            date(o) <- date;
            FOR order(INTEGER iod) = io NEW od = OrderDetail DO {
                price(od) <- price(iod);
                sku(od) <- GROUP MAX Sku sku IF name(sku) = sku(iod); // находим sku с данным именем
            }
        }
    }
}
```
